<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://zhongming-unice.github.io/rss.xml"
      title="RSS feed for https://zhongming-unice.github.io/">
<title>cag_note</title>
<meta name="author" content="ming"><meta name="referrer" content="no-referrer"><link href="static/usual-org-front-matter.css" rel="stylesheet" type="text/css" /><link href="static/org-notes-style.css" rel="stylesheet" type="text/css" /><link href="static/floating-toc.css" rel="stylesheet" type="text/css" /><link href="static/blog-banner.css" rel="stylesheet" type="text/css" /><link rel="icon" href="static/favicon.ico"></head>
<body>
<div id="preamble" class="status"><div class="header">  <div class="sitelinks">    <a href="https://zhongming-unice.github.io/about.html">about</a>    | <a href="https://zhongming-unice.github.io/archive.html">archive</a>    | <a href="https://zhongming-unice.github.io/rss.xml">rss</a>  </div></div></div>
<div id="content">
<div class="post-date">08  6 2021</div><h1 class="post-title"><a href="https://zhongming-unice.github.io/2021-06-08-cag_note.html">cag_note</a></h1>
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org00defa1">1. base</a></li>
<li><a href="#orge5f0986">2. tank</a>
<ul>
<li><a href="#org8aea5ac">2.1. lobby</a></li>
</ul>
</li>
<li><a href="#org73235b2">3. revise</a></li>
<li><a href="#org762edca">4. cmake</a></li>
<li><a href="#orgab9c25e">5. redis</a></li>
<li><a href="#orgef6c9f8">6. ssdb</a></li>
<li><a href="#orgbb11dd7">7. protobuf</a></li>
</ul>
</div>
</nav>

<div id="outline-container-org00defa1" class="outline-2">
<h2 id="org00defa1"><span class="section-number-2">1</span> base</h2>
<div class="outline-text-2" id="text-1">
<hr>

<dl class="org-dl">
<dt>ThreadType 线程类型枚举</dt><dd><ul class="org-ul">
<li>log</li>
<li>net</li>
<li>job</li>
<li>common</li>
</ul></dd>

<dt>ThreadBase 线程基类</dt><dd><ul class="org-ul">
<li>type(enum ThreadType)</li>
<li>fixed_frame_time: 30 milliseconds</li>
<li>thread_handle(thread *)</li>
<li>Run(): 每次循环过 fixed_frame_time 个 milliseconds, 每次循环调用 Update(), 如果 update spend time 小于 frame time 就 sleep</li>
<li>Destroy(): thread_handle join and then delete</li>
<li>待定义的虚函数: Push(), OnInit(), Update(), OnDestroy()</li>
</ul></dd>
</dl>

<hr>

<dl class="org-dl">
<dt>NetConnId 网络连接信息</dt><dd><ul class="org-ul">
<li>sid(session id)</li>
<li>conn_type(local services and external services)
以 tank 为例:
<ul class="org-ul">
<li><p>
lobby
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">mp (local)</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">world</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">db</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">match</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">pa</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">mail</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left">sp -&gt; pas/sns/team/prom/chat/max</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-left">ranking</td>
<td class="org-right">8</td>
</tr>

<tr>
<td class="org-left">pivot</td>
<td class="org-right">9</td>
</tr>

<tr>
<td class="org-left">pse</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-left">season</td>
<td class="org-right">11</td>
</tr>

<tr>
<td class="org-left">pay</td>
<td class="org-right">12</td>
</tr>

<tr>
<td class="org-left">gm</td>
<td class="org-right">13</td>
</tr>

<tr>
<td class="org-left">chat</td>
<td class="org-right">14</td>
</tr>

<tr>
<td class="org-left">max</td>
<td class="org-right">15</td>
</tr>
</tbody>
</table></li>
<li><p>
world
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">mp (local)</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">lobby (local)</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">gm</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table></li>
<li><p>
sp
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">lobby (local)</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">pas</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">sns</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">team</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">prom</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">chat</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left">max</td>
<td class="org-right">7</td>
</tr>
</tbody>
</table></li>
<li><p>
sns
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">lobby (local, lobby -&gt; sp -&gt; sns)</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">team</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">max</td>
<td class="org-right">5</td>
</tr>
</tbody>
</table></li>
<li><p>
prom
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">lobby proxy (local, lobby -&gt; sp -&gt; prom)</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">team (local)</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul></dd>
<dt>NetMsg 网络消息</dt><dd><ul class="org-ul">
<li>net_conn_id(conn_type, sid)</li>
<li>ts 时间戳: delay = GET_TIME().TickCount() - ts</li>
<li>msg</li>
</ul></dd>

<dt>MsgStat 消息状态</dt><dd><ul class="org-ul">
<li>msg_total</li>
<li>msg_in_min</li>
<li>msg_delay_in_min</li>
<li>msg_delay_distribution</li>
</ul></dd>

<dt>JobBase 任务基类</dt><dd><ul class="org-ul">
<li>net_msg(map&lt;int, NetMsg *的队列&gt;): &lt;conn_type, deque of NetMsg *&gt;</li>
<li>msg_stat(map&lt;int, MsgStat&gt;): &lt;conn_type, MsgStat&gt;</li>
<li>perf_log_timer(CTinyTimer): 时钟周期为60秒的 Timer</li>
<li>type(enum ThreadType): job_thread</li>
<li>perf_info(string)</li>
<li>OutputPerfInfo(now): 每过60秒, 将平均的 delay 和 delay 的分布写入日志</li>
<li>ProcessNetMsg(now): 处理消息队列, 使用 MsgParser(根据不同的 conn_type 有不同的 parser) 解析网络消息, 更新消息状态</li>
<li>Tick(now): 调用 OutputPerfInfo 和 ProcessNetMsg</li>
<li>OnMsg(type, msg): 插入新消息</li>
</ul></dd>

<dt>LogicThread 逻辑处理线程 : ThreadBase</dt><dd><ul class="org-ul">
<li>job_pointer(JobBase *)</li>
<li>OnInit(): gtk_cag_service 创建 job/common thread</li>
<li>Update(): JobBase call Tick()</li>
<li>Push(): JobBase call OnMsg()</li>
</ul></dd>

<dt>ThreadManager 逻辑处理线程管理器</dt><dd><ul class="org-ul">
<li>common_thread(LogicThread *)</li>
<li>logic_thread_pool(vector of LogicThread *)</li>
<li>Init(file, frame_time): 读取 ini 配置文件中的 LogicThreadCount, 创建 logic_thread s 和 common_thread</li>
<li>PushMsg(thread_type, dispatch_id, msg): 
<ul class="org-ul">
<li>如果 thread_type 为 job_thread: 第 (id mod count) 个 logic 线程 call Push()
<ul class="org-ul">
<li>JobBase call OnMsg()</li>
</ul></li>
<li>否则 common 线程 call Push()
<ul class="org-ul">
<li>JobBase call OnMsg()</li>
</ul></li>
</ul></li>
<li>BroadcastMsg2AllLogicThread(): 广播消息到所有 LogicThread</li>
<li>push 一条消息的 backtrace:
<ul class="org-ul">
<li>service</li>
<li>ThreadManager</li>
<li>pool of LogicThreads</li>
<li>JobBase</li>
<li>map&lt;conn_type, deque of NetMsg&gt;</li>
<li>conn_type, sid, ts, msg</li>
</ul></li>
</ul></dd>
</dl>
<hr>

<dl class="org-dl">
<dt>LocalNetConfig 本地网络配置</dt><dd><ul class="org-ul">
<li>port</li>
<li>msg_header_type (8 或 24)</li>
<li>io_thread_count</li>
</ul></dd>

<dt>ExternalNetConfig 外部网络配置</dt><dd><ul class="org-ul">
<li>port</li>
<li>msg_header_type (8 或 24)</li>
<li>io_thread_count</li>
<li>ips(vectot of string)</li>
</ul></dd>
</dl>

<hr>

<dl class="org-dl">
<dt>MsgHandler : TCPSessionHandler 服务器消息处理</dt><dd><ul class="org-ul">
<li>conn_type</li>
<li>header_len</li>
<li>OnConnect(sid, ip, port): 
<ul class="org-ul">
<li>gtk_net_module call RecvNetMsg()</li>
<li>recv_msg push 一条消息(conn_type, sid, msg of connect_ack)</li>
</ul></li>
<li>OnMessage(sid, msg): 
<ul class="org-ul">
<li>对24字节头消息做处理后, get_net_module call RecvNetMsg() push 一条消息(conn_type, sid, msg of gamedata_ack)</li>
</ul></li>
<li>OnClose(sid, ip, port): 
<ul class="org-ul">
<li>gtk_net_module call RecvNetMsg() push 一条消息(conn_type, sid, msg of close_ack)</li>
</ul></li>
<li>一个 NetInterface 对应一个 MsgHandler</li>
</ul></dd>

<dt>NetObj 网络对象(server or client)</dt><dd><ul class="org-ul">
<li>sid: session id</li>
<li>ip</li>
<li>io_manager(TCPIOThreadManager *)</li>
<li>idle_timer(空闲时间)</li>
<li>Update(now): 
<ul class="org-ul">
<li>server - 如果 idle_timer 超过时钟周期 io_manager CloseSession</li>
<li>client - 如果 idle_timer 超过时钟周期 SendMsg(idle_req)</li>
</ul></li>
<li>SendMsg(msg): io_manager 调用 SendMsg2Session(sid, msg)</li>
<li>一个 NetInterface 有多个 NetObj, 一个 session 对应一个 NetObj</li>
</ul></dd>

<dt>NetInterface 网络接口(server or client)</dt><dd><ul class="org-ul">
<li>conn_type</li>
<li>msg_handler(shared_ptr of TCPSessionHandler)</li>
<li>io_thread(thread *)</li>
<li>io_manager(TCPIOThreadManager *)</li>
<li>net_obj(map&lt;int, NetObj *&gt;): &lt;sid, NetObj&gt;</li>
<li>client: ExternNetConfig, ip_2_sid(map), reconn_timer</li>
<li>server: LocalNetConfig</li>
<li>Update(now): 每个NetObj 调用 Update()
<ul class="org-ul">
<li>client - CheckReconnectServer()(1分钟)</li>
</ul></li>
<li>KickNetObj(sid): io_manager 调用 CloseSession(sid)</li>
<li>SendMsg(sid, msg): sid 对应的 NetObj 调用 SendMsg(msg)</li>
<li>OnConnected(msg): 根据 msg-&gt;sid 插入 NetObj
<ul class="org-ul">
<li>client - 初始化 ip_2_sid(一个 peer ip 对应一个 sid)</li>
</ul></li>
<li>OnIdleMsg(sid): only for server, NetObj reset idle timer(3分钟)</li>
</ul></dd>

<dt>NetWorker 网络工作线程 : ThreadBase</dt><dd><ul class="org-ul">
<li>fixed_frame_time = 1</li>
<li>Update(now): get_net_module 调用 Update()</li>
<li>一个 NetModule 对应一个 NetWorker</li>
</ul></dd>

<dt>NetModule 网络模块</dt><dd><ul class="org-ul">
<li>conn_id_lock(shared_mutex 用于读写锁)
<ul class="org-ul">
<li>std::unique_lock&lt;std::shared_mutex&gt; write lock
<ul class="org-ul">
<li>只有一个线程/写者能写</li>
</ul></li>
<li>std::shared_lock&lt;std::shared_mutex&gt; read lock
<ul class="org-ul">
<li>多个线程/读者能同时读</li>
</ul></li>
</ul></li>
<li>local_net_config(map&lt;int, LocalNetConfig *&gt;): &lt;conn type, config&gt; 本地服务器配置(ini)</li>
<li>external_net_config(map&lt;int, ExternalNetConfig *&gt;): 外部服务器配置</li>
<li>net_interface(map&lt;int, NetInterface *&gt;): &lt;conn_type, interface(server or client)&gt;</li>
<li>net_worker(Networker *)</li>
<li>conn_cid_2_ip(map&lt;NetConnId, string&gt;): &lt;conn_id, peer_ip&gt;</li>
<li>conn_type_2_sids(map&lt;int, set&lt;uint&gt;&gt;): &lt;conn_type, set of sid&gt;</li>
<li>recv_msg(deque&lt;NetMsg*&gt;)</li>
<li>send_msg(deque&lt;NetMsg&gt;)</li>
<li>Update(now): ProcessRecvMsg(), ProcessSendMsg(), UpdateNetInterface()</li>
<li>ProcessRecvMsg(): 从 recv_msg 中取出一个 NetMsg, 根据 msg 的 header 调用 
<ul class="org-ul">
<li>OnConneted()(connect | ack)</li>
<li>OnClosed()(close | ack)</li>
<li>OnIdleMsg()(idle | req)</li>
<li>OnGameMsg()(game or web | req or ack)</li>
</ul></li>
<li>ProcessSendMsg(): 从 send_msg 中取出一个 NetMsg, 根据 msg 的 conn_type 找到对应的 NetInterface, SendMsg()</li>
<li>UpdateNetInterface(): 每个 NetInterface call Update()</li>
<li>OnConnected(): 将 msg 中的 conn_id 和 peer_ip 插入 conn_id_2_ip, 将 conn_id 的 sid 加入 conn_type 对应的 set, conn_type 对应的 NetInterface call OnConnected(), gtk_cag_service call DispatchRevbMsg()</li>
<li>OnClosed(): 类似 OnConnected()</li>
<li>OnIdleMsg(): 根据 msg 的 conn_type 找到对应的 NetInterface call OnIdleMsg()</li>
<li>OnGameMsg(): gtk_cag_service call DispatchRecvMsg()</li>
<li>一个 CAGService 对应一个 NetModule</li>
</ul></dd>
</dl>


<ul class="org-ul">
<li>对应关系: 
<ul class="org-ul">
<li>sid -&gt; NetObj</li>
<li>conn_type -&gt; NetInterface</li>
<li>conn_type -&gt; set of sid</li>
<li>[conn_type, sid] -&gt; peer_ip</li>
</ul></li>
</ul>

<hr>

<dl class="org-dl">
<dt>CAGService</dt><dd><ul class="org-ul">
<li>net_module(NetModule *)</li>
<li>thread_manager(ThreadManager *)</li>
<li>thread_frame_time</li>
<li>local_ip</li>
<li>msg_parser(map&lt;int, MsgParser *&gt;)</li>
<li>module_msg_parser(map&lt;int, MsgParser *&gt;)</li>
<li>output_stat_timer</li>
<li>check_external_order_timer</li>
<li>net_event_msg(deque&lt;NetMsg *&gt;): connect/close ack msg</li>
<li>DispatchRecvMsg(msg): connect/close: call OnClosed()/OnConnected(), other: call ThreadManager::PushMsg()</li>
</ul></dd>
</dl>


<ul class="org-ul">
<li>消息队列: 
<ul class="org-ul">
<li>NetModule(recv_msg, send_msg)</li>
<li>JobBase(net_msg)</li>
<li>GAGService(net_event_msg)</li>
</ul></li>

<li>消息路径:
<ul class="org-ul">
<li>NetModule::ProcessRecvMsg()</li>
<li>CAGService::DispatchRecvMsg()
<ul class="org-ul">
<li>非 connect/close msg 就从 NetModule 中的 recv_msg ThreadManager::PushMsg() 到了 JobBase 中的 net_msg</li>
<li>connect/close msg 通过 service 的 ProcessNetMsg() 处理, 不进入 JobBase 中</li>
</ul></li>
</ul></li>
</ul>
<hr>

<dl class="org-dl">
<dt>CTinyTimer</dt><dd><ul class="org-ul">
<li>tick_term 时钟周期</li>
<li>tick_old</li>
<li>tick_begin</li>
<li>left_time: 剩余时间 = term - (now - begin)</li>
<li>CountingTimer(int): 如果经过的时间超过了时钟周期 
<ul class="org-ul">
<li>if (now - old &gt; term) 
<ul class="org-ul">
<li>old = begin = now</li>
<li>return true</li>
</ul></li>
</ul></li>
</ul></dd>

<dt>TimeSystem</dt><dd><ul class="org-ul">
<li>begin: 用于 windows 下记录初始化时的 GetTickCount</li>
<li>t_start: 用于 linux 下记录初始化时的 tick count</li>

<li>now: time()</li>
<li>timeT: 每次 update 时更新为 time()</li>
<li>TM: 每次 update 时更新为 localtime_r(const time_t *timeT, struct tm *result)</li>
<li>_CurrentTime(): 离操作系统启动所经过的毫秒数, _tend - _tstart, _tend 使用 gettimeofday(struct timeval *tv, struct timezone *tz) 获取</li>
<li>TickCount(): 离 Init() 所经过的毫秒数</li>
</ul></dd>

<dt>(no term)</dt><dd><p>
time functions
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Precision</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">time(2)</td>
<td class="org-left">time_t</td>
<td class="org-left">second</td>
</tr>

<tr>
<td class="org-left">gettimeofday(2)</td>
<td class="org-left">struct timeval</td>
<td class="org-left">microsecond</td>
</tr>

<tr>
<td class="org-left">clock_gettime(2)</td>
<td class="org-left">struct timespec</td>
<td class="org-left">nanosecond</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>time/gettimeofday/clock_gettime 都可以使用 vdso, 可以不陷入内核粗粒度地获取时间, clock_gettime 需要指定 CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE</li>
</ul></dd>
<dt>(no term)</dt><dd><p>
tm struct
</p>
<div class="org-src-container">
<pre class="src src-c">#include &lt;time.h&gt;
	   struct tm {
	     int tm_sec;    /* Seconds (0-60) */
	     int tm_min;    /* Minutes (0-59) */
	     int tm_hour;   /* Hours (0-23) */
	     int tm_mday;   /* Day of the month (1-31) */
	     int tm_mon;    /* Month (0-11) */
	     int tm_year;   /* Year - 1900 */
	     int tm_wday;   /* Day of the week (0-6, Sunday = 0) */
	     int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */
	     int tm_isdst;  /* Daylight saving time */
	 };
</pre>
</div></dd>
<dt>(no term)</dt><dd><p>
timeval struct
</p>
<div class="org-src-container">
<pre class="src src-c">#include &lt;sys/time.h&gt;
	   struct timeval {
	     time_t      tv_sec;     /* seconds */
	     suseconds_t tv_usec;    /* microseconds */
	 };

</pre>
</div></dd>
<dt>(no term)</dt><dd><p>
timezone struct
</p>
<div class="org-src-container">
<pre class="src src-c">  struct timezone {
    int tz_minuteswest;     /* minutes west of Greenwich */
    int tz_dsttime;         /* type of DST correction */
};
</pre>
</div></dd>
<dt>(no term)</dt><dd><p>
timespec struct
</p>
<div class="org-src-container">
<pre class="src src-c">  struct timespec {
	time_t          tv_sec;
	long            tv_nsec;
};
</pre>
</div></dd>

<dt>(no term)</dt><dd>Convert tm structure to time_t
time_t mktime (struct tm * timeptr);</dd>

<dt>(no term)</dt><dd><p>
Convert time_t to tm as local time
struct tm * localtime (const time_t * timer);
</p>

<p>
struct tm *localtime_r(const time_t *timep, struct tm *result);
</p>
<div class="org-src-container">
<pre class="src src-c">setenv("TZ", "/usr/share/zoneinfo/Asia/Shanghai", 1); // POSIX-specific
</pre>
</div></dd>

<dt>(no term)</dt><dd>Convert time_t to tm as UTC time
struct tm * gmtime (const time_t * timer);</dd>
</dl>

<hr>

<dl class="org-dl">
<dt>LogChannel</dt><dd><ul class="org-ul">
<li>FmtFixPath(path, name): 将 fixed_path_ 设为 "./log/path_name", 将 log_path_ 设为 0</li>
<li>FmtLogPath(): 将 log_path_ 设为 "fixed_path__.year-month-day.log"</li>
<li>Push(msg): write_pos_ 大于缓存大小时记录到 LogDiscard, 否则加锁将 msg 写入 cache_log_</li>
<li>Pop(exchange_log): 更新 log_path_, 加锁, cache_log_ 拷贝到 exchange_log, write_pos_ 设为 0</li>
</ul></dd>

<dt>LogSys : ThreadBase, 单例模式</dt><dd><ul class="org-ul">
<li>fixed_frame_time_ = 5 秒</li>
<li>Init(): 开个线程调用 OnInit()</li>
<li>channels(map&lt;int, LogChannel&gt;)</li>
<li>refresh_fmt_path(CTinyTimer): 60 秒更新一次所有 channel 的 log_path_</li>
<li>prefix_name: log 的名字前缀, 如 world, lobby</li>
<li>Register(type, name): channels 添加值键对 &lt;type, Init(prefix_name, name, cache_size_)&gt;</li>
<li>Push(type, msg): push msg 到相对应 type 的 channel</li>
<li>Save(path): 将 exchange_log_ 写入 path</li>
<li>Update(): 更新所有 channels 的 log_path_, 将它们的 cache_log_ 拷贝到 exchange_log_, 然后写入 log_path_</li>
<li>LOG_USERDEF_START: 拓展 log 类型的 enum 开始值(= 9)</li>
</ul></dd>
</dl>

<hr>

<dl class="org-dl">
<dt>Ini</dt><dd><ul class="org-ul">
<li>curSection(*map&lt;string, int&gt;)</li>
<li>sectionData(map&lt;string, *map&lt;string, int&gt; &gt;)</li>
<li>Open(filename): 循环读取每一行, 如果是 section(以 [] 开头结尾), sectionData 插入新的 section, 如果是 key = value, curSection 就插入新的值键对</li>
<li>GetInt/Float/Text(): 用 atoi/atof/strncpy 获取指定 section, key 的值</li>
<li>TrimString: 修剪文本, 结尾回车符转成 0, ';' 转成结尾标识符, 空格和 tab 转成 0</li>
</ul></dd>

<dt>TABFile</dt><dd><ul class="org-ul">
<li>field: union, int/float/string, field 之间要用 tab 分隔</li>
<li>data_buf: vector&lt;field&gt;, size = 行数 * 列数</li>
<li>hash_index: ordered_map&lt;int, field *&gt;, 以 field 的 int 值寻找 field</li>
<li><p>
OpenFromTXT(): 
</p>
<div class="org-src-container">
<pre class="src src-c++"># 获取二进制文件字节数
fseek(fp, 0, SEEK_END);
auto filesize = ftell(fp);
fseek(fp, 0, SEEK_SET);
</pre>
</div></li>
<li>GetFieldsNum/GetRecordsNum(): 获取列/行数</li>
</ul></dd>
</dl>

<hr>

<ul class="org-ul">
<li>tk cag header: msg type, msg length</li>
<li>tk net connected ack: cag header, sid, port, peer ip</li>
<li>tk net closed ack: cag header, sid, port, peer ip</li>
<li>tk cag srv header: cag header, player id, dispatch id</li>
</ul>

<hr>
</div>
</div>

<div id="outline-container-orge5f0986" class="outline-2">
<h2 id="orge5f0986"><span class="section-number-2">2</span> tank</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org8aea5ac" class="outline-3">
<h3 id="org8aea5ac"><span class="section-number-3">2.1</span> lobby</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>领取成就奖励: TankGainAchievementAwardReq(achievement_id, repeated select_params)
<ul class="org-ul">
<li>ThreadBase::Run()</li>
<li>TankLobbyWorker(JobBase)::Tick()</li>
<li>JobBase::ProcessMsg()</li>
<li>TankMPMsgParser::ParseTankGainAchievementAwardReq()</li>
<li>TankPlayer::GainAchieveAward()</li>
<li>CAGService::GetAchieveRuler()</li>
<li>TankPlayer::SendExchangeItemAck()</li>
<li>TankPlayer::SendAchievementAwardAckMsg()</li>
<li>AchieveRuler::MultiSelectAchieveAward()</li>
<li>TankPlayer::SaveDBData()</li>
<li>LobbyService::SendMsg2DB()</li>
<li>NetModule::SendNetMsg()</li>
</ul></li>

<li>断开连接:
<ul class="org-ul">
<li>ThreadBase::Run()</li>
<li>NetWorker::Update()</li>
<li>NetModule::Update(), ProcessRecvMsg(), OnClose(), DelConnIP()</li>
<li>CAGService::DispatchRecvMsg(), ProcessNetStateMsg()</li>
<li>LobbyService::OnClosed()
<ul class="org-ul">
<li>MP 关闭: BroadcastLocalMsg(), ThreadManager::BroadcastMsg2AllLogicThread()</li>
<li>world/db/pa&#x2026; 关闭: DelNetSid()</li>
</ul></li>
</ul></li>

<li>选择坦克:
<ul class="org-ul">
<li><p>
msg: TankChooseTankReq
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">chosen_tank_id</td>
</tr>

<tr>
<td class="org-left">is_trail 试玩</td>
</tr>
</tbody>
</table></li>
<li>Player::ChoseTank(), GetUsedTank(), UpdatePlayerSnsSignupData()</li>
</ul></li>

<li>购买物品
<ul class="org-ul">
<li><p>
msg: CagBuyshopItemReq
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">rack_id</td>
</tr>

<tr>
<td class="org-left">item_id</td>
</tr>

<tr>
<td class="org-left">purchase_count</td>
</tr>

<tr>
<td class="org-left">pay_type</td>
</tr>
</tbody>
</table></li>
<li>Shop::BuyItem(), CanBuyShopItem()</li>
<li>ShopItemExist(), CanBuyOnceItem(), PurchaseLimited(), CostJJMoney/RMB(), PlayerCanAfford()</li>
<li>ExeBuyItem(), BuyItemCostGameMoney(), SendBuyItemResultMsg()</li>
</ul></li>

<li>Login
<ul class="org-ul">
<li><p>
msg: CagPlayerLoginReqMsg
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">null_value</td>
</tr>
</tbody>
</table></li>
<li>Player::RegisterPlayer2World()</li>
</ul></li>

<li>Logout
<ul class="org-ul">
<li><p>
msg: CagPlayerLogoutReqMsg
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">null_value</td>
</tr>
</tbody>
</table></li>
<li>Player::Logout()</li>
<li>DelayOffline(), SendLeaveLobbyMsg(), UnregisterPlayer2Mail/Season/Chat()</li>
</ul></li>

<li>Player init
<ul class="org-ul">
<li><p>
msg: CagPlayerEnterReqMsg
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">nick</td>
</tr>

<tr>
<td class="org-left">figure</td>
</tr>

<tr>
<td class="org-left">user_id</td>
</tr>
</tbody>
</table></li>
<li>Player::Init()</li>
<li>PlayerBP()(赛季任务), PlayerTask(), Brisk()(活跃度), ExchangeResult()</li>
</ul></li>

<li>serialize player brisk DB data
<ul class="org-ul">
<li><p>
msg: PlayerBriskDBData
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">daily_brisk 日玩家活跃度</td>
</tr>

<tr>
<td class="org-left">period_brisk 自定义时间段活跃度</td>
</tr>
</tbody>
</table>
<p>
Brisk
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">degree 活跃度</td>
</tr>

<tr>
<td class="org-left">award_step 已领取奖励步</td>
</tr>

<tr>
<td class="org-left">last_tm 上次刷新时间</td>
</tr>
</tbody>
</table></li>
<li>Player::CheckTimerSaveDB()(120s)</li>
<li>Brisk::ToPB()(更新 Brisk msg)</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org73235b2" class="outline-2">
<h2 id="org73235b2"><span class="section-number-2">3</span> revise</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>tkcagbase/deps/util/ini.h
<ul class="org-ul">
<li>宏定义 Assert 中 exit() 修改为全局的 ::exit()</li>
</ul></li>
<li>tkcagbase/src/core/player_manager.cpp
<ul class="org-ul">
<li>PlayerManager::CreatePlayer(int) 中的 return false 改为 return nullptr</li>
</ul></li>
<li>boost/cstdint.hpp
<ul class="org-ul">
<li>typedef 将 boost 中的 int64_t/uint64_t 定义为 stdint.h 中的 int64_t/uint64_t</li>
</ul></li>
<li>所有 struct tm 初始化时将 tm_isdst 设为 -1</li>
<li>tank/tanklobby/src/battlepass/bp_config.cpp
<ul class="org-ul">
<li>#include &lt;io.h&gt; 改为 #include &lt;sys/io.h&gt;, 或把 /usr/include/sys 加到头文件搜索路径</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org762edca" class="outline-2">
<h2 id="org762edca"><span class="section-number-2">4</span> cmake</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>添加编译选项: add_compile_options(-g -O0 -std=c++17 -D_DEBUG -D__LINUX__ -Wno-enum-compare)</li>
<li>获取父目录: get_filename_component(PARENT_DIR ${PROJECT_SOURCE_DIR} DIRECTORY)</li>
<li>打印信息: message(STATUS "parent directory is: " ${PARENT_DIR})</li>
<li>指定可执行文件存放目录: set(EXECUTABLE_OUTPUT_PATH ${PARENT_DIR}/bin)</li>
<li>添加 protobuf 的头文件路径和链接库:
<ul class="org-ul">
<li>find_package(Protobuf)</li>
<li>include_directories(${Protobuf_INCLUDE_DIRS})</li>
<li>target_link_libraries(a.out ${Protobuf_LIBRARIES} pthread)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgab9c25e" class="outline-2">
<h2 id="orgab9c25e"><span class="section-number-2">5</span> redis</h2>
<div class="outline-text-2" id="text-5">
<dl class="org-dl">
<dt>normal value</dt><dd><ul class="org-ul">
<li>set</li>
<li>get</li>
<li>setnx: set if no exists</li>
<li>incr</li>
<li>del</li>
</ul></dd>

<dt>list value</dt><dd><ul class="org-ul">
<li>rpush: 尾部 push</li>
<li>lpush: 头部 push</li>
<li>rpop</li>
<li>lpop</li>
<li>llen: 长度</li>
<li>lrange</li>
<li>del</li>
</ul></dd>

<dt>set value, 值唯一</dt><dd><ul class="org-ul">
<li>sadd: 添加元素</li>
<li>srem: 删除元素</li>
<li>sismember: 测试元素是否存在</li>
<li>smembers: 返回所有元素</li>
<li>sunion: 合并多个 set</li>
<li>del</li>
</ul></dd>

<dt>sorted set(zset), value 通过 score 排序, 值唯一</dt><dd><ul class="org-ul">
<li>zadd key score1 member1 [score2 member2]</li>
<li>zrange [withscores]</li>
<li>del</li>
</ul></dd>

<dt>hash value, field 唯一</dt><dd><ul class="org-ul">
<li>hset key field value</li>
<li>hmset key field1 value1 [field2 value2]</li>
<li>hget</li>
<li>hgetall</li>
<li>hincrby</li>
<li>hdel</li>
<li>del</li>
</ul></dd>
</dl>
</div>
</div>

<div id="outline-container-orgef6c9f8" class="outline-2">
<h2 id="orgef6c9f8"><span class="section-number-2">6</span> ssdb</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li>todo</li>
</ul>
</div>
</div>
<div id="outline-container-orgbb11dd7" class="outline-2">
<h2 id="orgbb11dd7"><span class="section-number-2">7</span> protobuf</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>序列化(二进制信息保存到字符串): p1.SerializeToString(&amp;str);</li>
<li>反序列化: p2.ParseFromString(str);</li>
<li>SerializeToOstream(ostream *output);</li>
<li>ParseFromIstream(istream *input);</li>
<li><p>
将 pb 文本信息保存到字符串: 
</p>
<div class="org-src-container">
<pre class="src src-c++">#include "google/protobuf/text_format.h"
google::protobuf::TextFormat::PrintToString(p, &amp;str);
</pre>
</div></li>
<li><p>
将 pb 文本信息写入文件:
</p>
<div class="org-src-container">
<pre class="src src-c++">#include &lt;fstream&gt;
#include "google/protobuf/io/zero_copy_stream_impl.h"
#include "google/protobuf/text_format.h"

std::ofstream fw;
fw.open("./a.txt", std::ios::out | std::ios::binary);

google::protobuf::io::OstreamOutputStream *output =
  new google::protobuf::io::OstreamOutputStream(&amp;fw);

google::protobuf::TextFormat::Print(p, output);

delete output;
fw.close();

</pre>
</div></li>
<li>add: 添加一个子对象的指针</li>
<li>size: 返回 repeated 的 size</li>
<li>mutable: 取子对象的指针</li>
</ul>
</div>
</div>
<div class="taglist"><a href="https://zhongming-unice.github.io/tags.html">Tags</a>: <a href="https://zhongming-unice.github.io/tag-c++.html">c++</a> </div></div>
<div id="postamble" class="status"></div>
</body>
</html>
