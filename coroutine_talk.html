<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://zhongming-unice.github.io/rss.xml"
      title="RSS feed for https://zhongming-unice.github.io/">
<title>c/c++ 中的协程</title>
<meta name="author" content="ming"><meta name="referrer" content="no-referrer"><link href="static/usual-org-front-matter.css" rel="stylesheet" type="text/css" /><link href="static/org-notes-style.css" rel="stylesheet" type="text/css" /><link href="static/floating-toc.css" rel="stylesheet" type="text/css" /><link href="static/blog-banner.css" rel="stylesheet" type="text/css" /><link rel="icon" href="static/favicon.ico"></head>
<body>
<div id="preamble" class="status"><div class="header">  <div class="sitelinks">    <a href="https://zhongming-unice.github.io/about.html">about</a>    | <a href="https://zhongming-unice.github.io/archive.html">archive</a>    | <a href="https://zhongming-unice.github.io/rss.xml">rss</a>  </div></div></div>
<div id="content">
<div class="post-date">23 11 2021</div><h1 class="post-title"><a href="https://zhongming-unice.github.io/coroutine_talk.html">c/c++ 中的协程</a></h1>
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org117ad0f">1. 什么是协程</a></li>
<li><a href="#org7af6d54">2. 进程, 线程和协程</a>
<ul>
<li><a href="#orgc20b6a3">2.1. 进程和线程的上下文</a></li>
<li><a href="#org0a13d80">2.2. 协程的上下文</a></li>
</ul>
</li>
<li><a href="#org519a892">3. c++ 20 coroutine ts</a></li>
<li><a href="#org25d888c">4. 生产者消费者问题</a></li>
<li><a href="#org5cbbff2">5. conclusion</a></li>
<li><a href="#orgfa2cf44">6. references</a></li>
</ul>
</div>
</nav>
<div id="outline-container-org117ad0f" class="outline-2">
<h2 id="org117ad0f"><span class="section-number-2">1</span> 什么是协程</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>从来源来说 Conway Melvin E 1963的文章《Design of a Separable Transition-Diagram Compiler》提出协程是可以挂起 (suspend) 和恢复 (resume) 的子例程 (subroutine), 为了实现这一点需要保存上下文 (context)</li>
</ul>


<figure>
<img src="./images/foobar.png" alt="foobar.png">

<figcaption><span class="figure-number">Figure 1: </span><a href="https://www.boost.org/doc/libs/1_57_0/libs/coroutine/doc/html/coroutine/intro.html">foobar</a></figcaption>
</figure>


<ul class="org-ul">
<li>从控制流 (control flow) 的角度来说是一种语言层面 (language-level) 的控制流, 进程和线程中的逻辑控制流是由操作系统内核调度的, 而协程则是在语言层由程序员编写</li>
</ul>
</div>
</div>


<div id="outline-container-org7af6d54" class="outline-2">
<h2 id="org7af6d54"><span class="section-number-2">2</span> 进程, 线程和协程</h2>
<div class="outline-text-2" id="text-2">
<p>
本文中提到的线程一般指的是 linux 2.6 后 glibc 中的 NPTL (Native POSIX Threads Library) 实现的线程, 一个用户态线程 posix thread 对应一个内核态轻量级进程 light-weight process
</p>

<p>
操作系统用 <a href="https://elixir.bootlin.com/linux/v5.15/source/include/linux/sched.h#L723">task_struct</a> 这个结构体来描述一个进程或线程 (轻量级进程)
</p>

<p>
task_struct 有两个 id, <b>pid</b> 和 <b>tgid</b>, 类型均为 pid_t (x86_64 下为 int)
</p>
<ul class="org-ul">
<li>pid 可通过 syscall(SYS_gettid) 获取</li>
<li>tgid 可通过 getpid(2) 获取, 意为 thread group id, 即同一进程下的不同线程有不同的 pid 和相同的 tgid</li>
<li>clone(2) 中 flags 如设为 CLONE_THREAD, 意为创建线程 (轻量级进程), 创建出来的线程的 tgid 和调用这个函数的进程的 tgid 一致</li>
</ul>
<div class="org-src-container">
<pre class="src src-c">#include &lt;sched.h&gt;

int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...
            /* pid_t *ptid, void *newtls, pid_t *ctid */ );
</pre>
</div>

<p>
同一线程组 (进程) 下的线程共享虚拟内存 (virtual address space), 文件描述符表 (table of file descriptors) 和信号处理表 (table of signal handlers)
</p>

<p>
信号处理是 process-wide 的, 即对整个线程组产生影响, 但每个线程可以有自己的 signal mask, 信号可以通过 kill(2) 或 tgkill(2) 发送给进程或者线程 (a signal may be process-directed or thread-directed)
</p>
</div>

<div id="outline-container-orgc20b6a3" class="outline-3">
<h3 id="orgc20b6a3"><span class="section-number-3">2.1</span> 进程和线程的上下文</h3>
<div class="outline-text-3" id="text-2-1">
<p>
进程的上下文包括内存空间和寄存器, 也可以分为数据寄存器, 条件码, 栈指针, pc 这些程序上下文和虚拟内存结构体, 文件描述符表, brk 指针这些内核上下文
program context(data registers, condition codes, stack pointer, program counter) + kernel context(vm structures, descriptor table, brk pointer)
</p>

<p>
如CR3 寄存器保存着当前进程页目录的物理地址, 切换进程就会改变 CR3 的值 (part of the process' context)
</p>

<p>
每个线程都有属于它自己的局部 <a href="https://elixir.bootlin.com/glibc/latest/source/csu/errno.c#L31">errno</a>
</p>


<figure>
<img src="./images/vm.png" alt="vm.png" width="800px">

<figcaption><span class="figure-number">Figure 2: </span>virtual memory</figcaption>
</figure>
</div>
</div>


<div id="outline-container-org0a13d80" class="outline-3">
<h3 id="org0a13d80"><span class="section-number-3">2.2</span> 协程的上下文</h3>
<div class="outline-text-3" id="text-2-2">
<p>
协程的上下文由具体实现决定, 一般都远小于线程的上下文
</p>
</div>
</div>
</div>

<div id="outline-container-org519a892" class="outline-2">
<h2 id="org519a892"><span class="section-number-2">3</span> c++ 20 coroutine ts</h2>
<div class="outline-text-2" id="text-3">

<figure>
<img src="./images/echo.png" alt="echo.png" width="800px">

<figcaption><span class="figure-number">Figure 3: </span>echo server</figcaption>
</figure>
</div>
</div>


<div id="outline-container-org25d888c" class="outline-2">
<h2 id="org25d888c"><span class="section-number-2">4</span> 生产者消费者问题</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>进程: 通过 futex 同步, 映射到同一个物理内存地址的 futex 变量</li>

<li>线程: 通过 futex 同步, 共享虚拟内存空间中的 futex 变量</li>

<li>协程: 通过用户定义的变量同步</li>
</ul>


<figure>
<img src="./images/producer-consumer.png" alt="producer-consumer.png" width="800px">

<figcaption><span class="figure-number">Figure 4: </span>producer-consumer problem</figcaption>
</figure>
</div>
</div>

<div id="outline-container-org5cbbff2" class="outline-2">
<h2 id="org5cbbff2"><span class="section-number-2">5</span> conclusion</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>fine-grained concurrency</li>

<li>cannot take advantage of multi-core</li>
</ul>
</div>
</div>

<div id="outline-container-orgfa2cf44" class="outline-2">
<h2 id="orgfa2cf44"><span class="section-number-2">6</span> references</h2>
<div class="outline-text-2" id="text-6">
<p>
<a href="https://en.wikipedia.org/wiki/Coroutine">coroutine wikipedia</a>
</p>

<p>
<a href="https://www.melconway.com/Home/pdf/compiler.pdf">Design of a Separable Transition-Diagram Compiler</a>
</p>

<p>
<a href="https://seriouscomputerist.atariverse.com/media/pdf/book/Art%20of%20Computer%20Programming%20-%20Volume%201%20(Fundamental%20Algorithms).pdf">Art of Computer Programming - Volume 1</a>
</p>

<p>
<a href="https://www.boost.org/doc/libs/1_57_0/libs/coroutine/doc/html/coroutine/intro.html">asio coroutine</a>
</p>

<p>
<a href="https://man7.org/linux/man-pages/man2/clone.2.html">clone(2) — Linux manual page</a>
</p>
</div>
</div>
<div class="taglist"></div></div>
<div id="postamble" class="status"></div>
</body>
</html>
